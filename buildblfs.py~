#!/bin/env  python
# Version 1.09
# 
# 
# 
# 

import urllib2,os,binascii,re,sys,platform,glob,time
try:
	from collections import OrderedDict
except ImportError:
	from ordereddict import OrderedDict
try:
	from BeautifulSoup import BeautifulSoup
except ImportError:
	from bs4 import BeautifulSoup

reload(sys) 
sys.setdefaultencoding('utf8')

blfsloc		="www.linuxfromscratch.org/blfs/view/svn/index.html"

CWD		=os.path.dirname(os.path.realpath(__file__))

SOURCES		='/sources'

blfspage	=CWD +	"/" + blfsloc

blfslocaldir	=os.path.dirname(blfspage)
soup 		= BeautifulSoup(open(blfspage).read())
funcstrip	= re.compile("\\b&nbsp;\\b|[ \~\:\+\.\-\?'\$\(\)\/\n\t\r]+",re.MULTILINE)
orstrip 	= re.compile("[ \t,\n\r]+",re.MULTILINE)

port 		= "port"
portdir 	= "/mnt/lfs/" + port
makefolder 	= portdir + "/makefiles"
scriptfolder	= portdir + "/scripts"
logfolder 	= portdir + "/logs"
perl_pack_lists= portdir +"/perl_pack_lists"
replace_log	=""
delete_log 	= ""
blfs_script_link=""
blfs_script_pkg =""
blfs_script_ver =""
allshortnames	=""
comment	="#This file is automatically generated, don't modify anyway\n"
comment 	+= "#Generated time is : " +  time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) + "\n"
ccounter=0
pcounter=0
wrapper="/sbin/blfsbuild"

blfsbuild='''\
#!/bin/bash
makedir=''' + makefolder.replace("/mnt/lfs","") + '''
makefile="${makedir}/Makefile"
NORMAL="\e[0m"
RED="\e[1;31m"
GREEN="\e[1;32m"


[ `id -u` = "0" ] || { echo "you are not root!"; exit 1;}

[ $# -ne 1 ] && { echo "Need one package name to initiate installation"; exit 1;}

packname=$1

ret=$(grep --color -oEi "^[^0-9]*${packname}.* :" "$makefile" | sed 's@:@@g')

counter=0
for r in $ret
do
counter=$((counter+1))
pkg[$counter]=$r
echo -e "$GREEN $r $NORMAL ${RED}[${NORMAL}${counter}${RED}]${NORMAL}:"
done
if [ $counter -gt 1 ] ; then
	echo "There are $counter matches found, which you do you want to install ?"

	select yn in ${pkg[@]}; do

		for a in "${pkg[@]}"
		do 
		    case $yn in
		       "$a") cd ${makedir} && make $yn;break;;
		    esac
		done
	    exit
	done
else if [ $counter -eq 1 ] ; then
	
		echo -e "Will install ${RED}${pkg[1]}${NORMAL} ,OK[Y/N]?"
		read -p ": " yn
		case $yn in
		y|Y) cd ${makedir} && make ${pkg[1]};;
		*)   exit ;;
		esac

     else 
		echo "No Match found,quit!"; exit 0
     fi
fi
	
'''
header='''\
PORTDIR=/port
D	= -x
SHELL 	= /bin/bash
SOURCES = /sources
LOGDIR	= $(PORTDIR)/logs
SCRIPTDIR = $(PORTDIR)/scripts
REDIRECT= > $(LOGDIR)/$@.log

BOLD    = "\e[0;1m"
RED     = "\e[1;31m"
GREEN   = "\e[0;32m"
ORANGE  = "\e[0;33m"
BLUE    = "\e[1;34m"
WHITE   = "\e[00m"
YELLOW  = "\e[1;33m"

OFF     = "\e[0m"
REVERSE = "\e[7m"

tab_    = '	'
nl_     = ''

define echo_message
  @echo -e $(BOLD)--------------------------------------------------------------------------------
  @echo -e $(BOLD)$(1) target $(BLUE)$@$(BOLD)$(WHITE)
endef

'''
header		= comment + header

scriptheader1='''\
#/bin/bash
set +h
set -e

SOURCES=/sources
'''
scriptheader2='''\
export MAKEFLAGS='-j 4'
env
preparepack()
{
cd ${SOURCES}
local shortname=$1
local version=$2
local packname=$3
rm -rf ${shortname}-${version} 
rm -rf ${shortname}-build
mkdir -pv ${shortname}-${version}  
case $packname in 
	*.zip)
	unzip -x $packname -d ${shortname}-${version}
	;;
	*)
	tar xf $packname -C ${shortname}-${version} --strip-components 1
	;;
esac
}

nwget()
{
local packlink=$1
wget --no-check-certificate -nc --timeout=60 --tries=5 $packlink -P ${SOURCES}
}
'''
perlcmd='''\
perl Makefile.PL &&
make &&
make test
make install
'''


def containsAny(str, set):
    """Check whether 'str' contains ANY of the chars in 'set'"""
    return 1 in [c in str for c in set]

def containsAll(str, set):
    """Check whether 'str' contains ALL of the chars in 'set'"""
    return 0 not in [c in str for c in set]



def base_init():

	if not os.path.exists(portdir):
		os.makedirs(portdir)	

	if not os.path.exists(scriptfolder):
		os.makedirs(scriptfolder)
	else :
		filelist = glob.glob(scriptfolder + "/*")
		for f in filelist:
			os.remove(f)

	if not os.path.exists(logfolder):
		os.makedirs(logfolder)

	
	if not os.path.exists(makefolder):
		os.makedirs(makefolder)

	if not os.path.exists(blfslocaldir):
		print blfslocaldir
		print blfsloc
		os.system("wget --recursive  --no-clobber --html-extension  --convert-links  --restrict-file-names=windows  --domains www.linuxfromscratch.org   --no-parent " + blfsloc)



globalreplace = [
		('&gt;',						'>'),
		('&lt;',						'<'),
		('&amp;',						'&'),
		('<PREFIX>',						'/opt'),
		("<newuser>",						'mao'),
		("<username>",						'mao'),
		("<password>",						'ping'),
		('export PATH="$PATH',					'export PATH=$PATH'),
		('<PREFIX>',						'/opt'),
		('dhclient <eth0>',					'dhclient eth0'),
		#('--docdir=/usr/share/doc/<udev-Installed LFS Version> &&', '--docdir=/usr/share/doc/' + str(udevversion) + ' &&'),
		(' /etc/openldap/schema                 &&',		' /etc/openldap/schema'),
		('mysqladmin -u root password <new-password>',		'mysqladmin -u root password ping'),
		(' $DOCNAME.dvi  &&',					' $DOCNAME.dvi'),
		('"EOF" &&',						'"EOF"'),
		 

]

globalregx = [
		(r"mkdir\s*-v",						"mkdir -pv"),
		(r"mkdir\s*/",							"mkdir -pv /"),
		(r"mkdir\s*",							"mkdir -pv "),
		(r"export\s*LANG=\s*<ll>_<CC>\.<charmap><@modifiers>",		"export LANG=en_US.utf8")

]

ignorelist = ['dummy',
	'REMOTE_HOSTNAME',
	'convmv -f iso-8859-1 -t cp850 -r --nosmart --notest \\'
	'    </path/to/unzipped/files>',
	'convmv -f cp866 -t koi8-r -r --nosmart --notest \\',
	'bash -e',
	'make -k check',
	'make check',
	'make test'
	]

def massreplaceline(string):
	global replace_log
	for k, v in OrderedDict(globalreplace).iteritems():

		if k in string:
			#print "Replacing :",k," with :",v,"\n"
			
			replace_log += "\nOrigin    : " + string + "\n"
			replace_log += "Replacing : " + k + " with : " + v  + "\n"
			replace_log += "Rules     : " + k + "\n"
			replace_log += "-------------------------------------------------\n"
   			string = string.replace(k, v)
			
	
	for k, v in OrderedDict(globalregx).iteritems():
		laststr = string
		#print laststr,"--------------------------"
		string = re.sub(k ,v, laststr)#,flags=re.DEBUG)
		#print string,"-====================="
		if string != laststr:
			#print string,"-====================="
			replace_log += "\nOrigin    : " + laststr + "\n"
			replace_log += "Replacing : " + laststr + " with : " + string  + "\n"
			replace_log += "Rules     : " + k + "\n"
			replace_log += "-------------------------------------------------\n"
		 

	return string



def replacem(str):
	if str !=None:
		return str.replace('&gt;','>').replace('&lt;','<').replace('&amp;','&')
	else:
		return 'REPLACEME'

def findchild(tag,tagname="kbd"):
	cmdline=""

	if tag.string!=None:
		tmpstr = replacem(tag.string)
		cmdline = cmdline + "\n" + tmpstr

	else:
		cmdline = cmdline + "\n"
		for code in tag.contents:
			#L2
			if code.string != None:
				cmdline = cmdline + replacem(code.string)
			else:
			
				for em in code.contents:
					#L3
					if em.string != None:
						cmdline = cmdline + "\t" +  replacem(em.string)
					
		cmdline = cmdline + "\n"						
	return cmdline

def grep(pattern,fileObj):
	
	for line in open(fileObj,'r'):
		
		if re.search(pattern,line,re.IGNORECASE):
			return line

def lineadd(lst,block,fullname):
	global delete_log
	if block:
		for i,line in enumerate(block.splitlines()):
			if line and line !="\n":
 
			 	if  containsAny(line,ignorelist):
					delete_log += "\n--------------------" + fullname + "-------------------------\n"
					delete_log += "Delete line : " + str(i) + " : " + line + " from :\n"
					delete_log += block + "\n"
					
					pass
		   		else:
				
					lst.append(massreplaceline(line) + "\n")

def parsename(pkgname):
	
	pkgname =  commonname(pkgname)
	namematch = re.search("^([a-zA-Z0-9]+(-[0-9]*[a-zA-Z]+[0-9]*)*)",pkgname)
	shortname = namematch.group(1).lower()
	return shortname

def parseversion(pkgname):
	versionmatch = re.search("-([0-9.]+)",pkgname)

	try:
		version = versionmatch.group(1)
	except AttributeError:
		version = ""
	return version
					
def parsedependency(depsoup):
	
	ps=depsoup.findAll("p",attrs={'class':re.compile(r"^(recommended|required)$")})
	if ps:
		dependstr_link=""

		for p in ps:
			child_iter = iter(p.contents)
			for child in child_iter:
				if  hasattr(child,"name"):

					if hasattr(child,"title"):
	
							pkgname = funcstrip.sub("-",child.text).lower()
							
							if containsAny(pkgname,["x-window-system"]):
								shortname =  "x-window-system-environment"
							else:
								shortname = parsename(pkgname)
							version = parseversion(child.text.lower())	
							dependstr_link += shortname + version + " "
					
				else:
					orstr = orstrip.sub("",child.string)
					if orstr=="or":
						next(child_iter,None)
						continue
					
		#dependstr_link += "\n"
	else:
		dependstr_link=""

	return dependstr_link

def parsepackname(download_link):
	packname=""
	
	if download_link:
		packmat = re.search("/([-.\w]*[^/]*\.*(tar)*\.*((zip)|(tar)|(bz2)|(xz)|(gz)|(tgz))+$)",download_link[0])
		
		try:
			packname = packmat.group(1)
		except AttributeError:
			packname = ""
	return packname
	

def parsedownload(subsoup,download_link):
	packname=""
	uls=subsoup.findAll("ul",attrs={'class':'compact'})
	counter=0
	if uls:
		
		for ul in uls:
			for alink in ul.findAll("a",attrs={'class':'ulink'}):
				#print alink['href']
				if str(alink['href']).endswith('/') or "certdata" in str(alink['href']) or str(alink['href']).endswith('.html') :
					pass  
				else:
					download_link.append(alink['href'])

	return parsepackname(download_link)


	
def scripttext(cmds,shortname,version,packname,download_links):
	cmdstr = []
	
	cmdstr.append(scriptheader1)
	cmdstr.append("pkgname=" + shortname + "\n")
	cmdstr.append("version=" + version + "\n")
	#cmdstr.append("export MAKEFLAGS='-j 4'\n")
	cmdstr.append(scriptheader2)
	
	if packname:
		for link in download_links:
			cmdstr.append("nwget " + link + "\n")
		cmdstr.append("preparepack \"$pkgname\" \"$version\" " + packname + "\n")
		cmdstr.append("cd ${SOURCES}/${pkgname}-${version} \n")

	for cmd in cmds:
		 
		if type(cmd) is not str:
			for p in cmd.parent.findPreviousSiblings():
				if p.findAll('a',{"title" : "BLFS Boot Scripts"}):
					cmdstr.append("nwget " + blfs_script_link + " \n")
					cmdstr.append("preparepack blfs-scripts " + blfs_script_ver + " " + blfs_script_pkg + "\n")
					cmdstr.append("cd ${SOURCES}/blfs-scripts" + "-" + blfs_script_ver + "\n")

			if cmd.parent.findPreviousSibling():
				prev = cmd.parent.findPreviousSibling().text.encode('utf-8').strip()
				if containsAny(prev, ['doxygen','Doxygen','texlive','TeX Live','Sphinx']) and not containsAny(prev,['Install Doxygen']):

					pass
				elif   containsAny(prev, ['documentation','manual']) and containsAny(prev, ['If you','API','alternate''optional','Sphinx','DocBook-utils','Additional']) and  not containsAny(prev,['If you downloaded','Man and info reader programs','The Info documentation system']):
					pass
				else:
				
					lineadd(cmdstr,findchild(cmd),shortname + "-" + version) # cmd.text.encode('utf-8').strip() + "\n" #
		else:
			cmdstr.append(cmd)
	if packname:	
		cmdstr.append("cd ${SOURCES}\n")
		cmdstr.append("rm -rf ${pkgname}-${version} \n")
		cmdstr.append("rm -rf ${pkgname}-build" + "\n")

	cmdstr.append("exit\n")
	return cmdstr

def parsecmds(soupsub,fullname):

	
	pagename = funcstrip.sub("-",fullname).lower()
	shortname = parsename(fullname)
	version   = parseversion(fullname)

	download_links=[]
	packname=""
	
	if  "libstdc" in shortname:
		shortname = "gcc"
	if "udev" in shortname:
		shortname = "systemd"
	global blfs_script_link,blfs_script_pkg,blfs_script_ver
	packname = parsedownload(soupsub,download_links)

	 
	if "blfs-boot-scripts" in pagename :
		blfs_script_link=download_links[0]
		blfs_script_pkg=packname
		blfs_script_ver=re.search("-([0-9]+)",packname).group(1)
		#print blfs_script_link
		#print blfs_script_pkg 
		#print blfs_script_ver


	cmds=soupsub.findAll("kbd",{'class':'command'})
	
	
	if  cmds:
		return scripttext(cmds,shortname,version,packname,download_links)
		


def parsepage(soupsub,fullname):
			
		page=[]
		page = parsecmds(soupsub,fullname.lower())
		return page	

def commonname(string):
	return funcstrip.sub("-",string).lower().encode('utf-8').strip().strip("-")

def dependname(string):
	shortname = parsename(commonname(string))
	version = parseversion(string)
	return shortname + version

def parseexternal(link):
	shortname = re.search(r'/([^/]*)/$',link,re.IGNORECASE).group(1) #like LWP-Protocol-https
	packlink=""
	if os.path.exists(perl_pack_lists):
		packlink = grep('/' + shortname + '[^/]*\.tar\.((bz2)|(xz)|(gz))$' ,perl_pack_lists)
	
	if packlink:
		return packlink
	else:
		soup = BeautifulSoup(urllib2.urlopen(link).read())
	
		alink = soup.findAll("a",attrs={'href':re.compile("tar\.gz")}) # package link
	
		if alink:
			match = re.search('(http://[^/]+/)',link) #http://search.cpan.org/
			download_link=" " +match.group(1) +  alink[0]['href'].strip("/") + "\n"
			file = open(perl_pack_lists,"a")
			file.write(download_link)
			file.close
			return download_link
		else:
			return ""


def parseperldownload(alink):
	
	if alink and alink.has_key('href'):
		
		if str(alink['href']).endswith('/'): #parse external link :http://search.cpan.org/~gaas/LWP-Protocol-https/
			
			return str(parseexternal(str(alink['href'])))
			#return alink['href']

		elif   ".html" in str(alink['href']):# same page no need to parse,ex:# /www.linuxfromscratch.org/blfs/view/svn/general/perl-modules.html#perl-lwp
					              #within BLFS, no need to parse
			pass

		else:                               # otherwises, need to parse all 

			return alink['href']
			
			#full_package_name = full_package_name + "\"\n\n"  
def parseperl(cmds):
	link = CWD + "/www.linuxfromscratch.org/blfs/view/svn/general/perl-modules.html"


	soup = BeautifulSoup(open(link).read())
	titles=soup.findAll('h3')
	pkglist=[]
	perlstr=""
	for title in titles:
		func = commonname(title.text).strip("-")
		#print title.text.encode('utf-8').strip()
		print "Parseing: ",func
		while title != None:
			title = title.findNextSibling(attrs={'class':'itemizedlist'})

			if title != None :#and #func == "Crypt_SSLeay_0_64" :
				#pid+=int(pid) + 1
				perldepend(title,"",cmds,pkglist)

			break

	return pkglist	


def perldepend(div,func,cmds,pkglist):
	
	if div.string == None:
		for ul in div.contents:
			 if ul.string == None:
				#print ul.a.text," parent : ul.text---------"
				deplist=""			
				downlinks=[]					
				for li in ul.contents:   # Iterate over lis
					exist=0
					if li.string == None:
						try:
							url = str(li.a['href'])
						except (KeyError,AttributeError):
							li.a = li.a.findNextSibling(attrs={'class':'ulink'})
							url = str(li.a['href'])
							
						if func and ".html" in url: # /home/tomwu/www.linuxfromscratch.org/blfs/view/svn/general/perl-modules.html#perl-lwp
									     # /home/tomwu/www.linuxfromscratch.org/blfs/view/svn/postlfs/openssl.html
							deplist += dependname(li.a.text) + "  "
							exist=1
						else:        #http://www.cpan.org/authors/id/N/NA/NANIS/Crypt-SSLeay-0.64.tar.gz/ TITLE

							deplist += dependname(li.a.text) + "  "
							downlinks = [ parseperldownload(li.a) ]
						shortname = parsename(commonname(li.a.text))
						version = parseversion(li.a.text)
						packname = parsepackname(downlinks)
						#cmds = perlcmd 
						pid = generatepid()
						pkg = pid + "-" + shortname
						pkglist.append(pkg)
						if packname:
							
							perlscript= scriptfolder + "/" + pkg + ".sh"
							file = open(perlscript,'wb')
							for s in scripttext(perlcmd,shortname,version,packname,downlinks):
								file.write(s)
								
							file.close

						if li.string == None and not li.div and not exist:
							 
							makefiletext(li.a,pid,"",cmds)

				if func:
					makefiletext(div.findPreviousSibling().a,pid,deplist,cmds)
				
				for li in ul.contents:  # Iterate over div of class itemizedlist
					if li.string == None and li.div:
						# Tiltle of next div need to be iterate, for example, Crypt::SSLeay-0.64
						#func = dependname(li.div.findPreviousSibling().a.text)
				
						perldepend(li.div,li.div.findPreviousSibling().a,cmds,pkglist)

	

def makefiletext(link,pid,dependency,cmds):
		
		pkgname =  commonname(link.text)
		shortname = parsename(pkgname)
		version = parseversion(link.text)

		pkg = pid + "-" + shortname
		subsect=[]
		if not containsAny(pkgname, ['configuring-for-adding-users','about-devices','the-bash-shell-startup-files','the-etc-shells-file','random-number-generation','compressing-man-and-info-pages','lsb']):
			subsect += ["\n" + shortname + version + " : after-lfs-configuration-issues " + pkg +"\n"]
		else:	
			subsect += ["\n" + shortname + version + " : " + pkg +"\n"]
		subsect += ["\t@touch $@\n"]

		subsect += ["\n" + pkg + " : " + dependency +"\n"]
		subsect += ["\t@$(call echo_message, Building)\n"]

		subsect += ["\t@time $(SHELL) $(D) $(SCRIPTDIR)/$@.sh $(REDIRECT) \n"]

		subsect += ["\t@touch $@\n"]

 		
		cmds.extend(subsect)					



def genscript(link,flag,cmds):
	#subtarget=""
	dependency = ""
			
	pkgname =  commonname(link.text)
	shortname = parsename(pkgname)
	version = parseversion(link.text)
	pid = generatepid()
	pkg = pid + "-" + shortname

	print "Generating: ",pkgname
	page= []

	if link.has_key("href") and not containsAny(pkgname, ['conventions-used-in-this-book','notes-on-building-software','locale-related-issues','python-modules']) :
		#Ignore those out of need
		sublink=os.path.dirname(blfspage) + "/"+link['href']
		soupsub = BeautifulSoup(open(sublink).read())
		
		page = parsepage(soupsub,link.string)
	elif flag == 1 : 
		print link.text,"---------------------"#for python modules/ Xorg drivers
		soupsub = link.parent
		
		page = parsepage(soupsub,link.text)
	if page:
		packmkfile= scriptfolder + "/" + pkg + ".sh"
		file = open(packmkfile,'wb')	
		for pag in page:
			file.write(pag)
		file.close
		dependency = parsedependency(soupsub)

		makefiletext(link,pid,dependency,cmds)

		return pkg
	else:
		return ""

def parsemultisect(link,cmds):
	
	sublink=os.path.dirname(blfspage) + "/"+link['href']
	
	soupsub = BeautifulSoup(open(sublink).read())
	titles=soupsub.findAll('h2',attrs={'class':'sect2'})
	pkg = ""
	flag= 1
	#print titles
	if titles:
		for title in titles:
			#print title.text
			#pid+=t(pid) + 1
			pkg +=genscript(title,flag,cmds) + " "

	return pkg
def generatepid():
	global ccounter,pcounter
	print ccounter,pcounter
	pcounter +=1
	return str(ccounter) + str(pcounter).zfill(2)

def parseindex():

	global ccounter,pcounter
	allchapters = "all : "
	chapter ="\n"
	

	cmds = []
	titles=soup.findAll("h4")
	lfsversion=soup.findAll("h2",attrs={'class':"subtitle"})
	if lfsversion:
		for v in lfsversion:
			release = v.text
	subchapter = ""
	subtarget=""
	tmptgt = ""
	sourcetgt=""
	systgt='''\
	@$(call echo_message, Building)
	@source /etc/profile  && make '''

	for title in titles:
		
		 
		chapter = commonname(title.text).strip('-')

		namematch = re.search("([a-zA-Z]+(-[a-zA-Z]+)*)",chapter)
		chaptertgt = namematch.group(1).lower() #not parsename(chapter)
		tmptgt += "\nmk-" + chaptertgt + " :  $(" + chapter + ")\n"
		if chaptertgt not in "after-lfs-configuration-issues":
			sourcetgt += "\n" + chaptertgt + " : after-lfs-configuration-issues \n" + systgt + " mk-" + chaptertgt + "\n"
		else:
			sourcetgt += "\n" + chaptertgt + " :  \n" + systgt + " mk-" + chaptertgt + "\n"
		sourcetgt += "\t@touch $@\n"
		subchapter +=  "\n" + chapter + " = " 
		allchapters +=  " $(" + chapter + ") "
		uls=title.findNextSiblings()
		for ul in uls:
			links= ul.findAll("a")
			
			
			for link in links:
				#pid = generatepid()

				if link.string in "Perl Modules":
					for pkg in parseperl(cmds):
						subchapter += pkg + " "
				if containsAny(link.string,["Python Modules","Xorg Drivers"]):
					subchapter  += parsemultisect(link,cmds)
				else:
					subchapter  += genscript(link,0,cmds) + " "
				 # loop for packages
			subchapter += "\n"
		ccounter += 1 # loop for chapters
		pcounter = 0
		print pcounter

	if cmds:
			mkfile= makefolder + "/Makefile"
			mainfile = open(mkfile,'wb')	
			mainfile.write("#Current LFS release is : " + release.replace("\n","") + "\n" + header)
			mainfile.write(allchapters) # all :  $(preface)  $(1-welcome-to-blfs)
			mainfile.write(subchapter) # 1-welcome-to-blfs = 101-conventions-used-in-this-book  
			mainfile.write(sourcetgt)
			mainfile.write(tmptgt) # welcome-to-blfs :  $(1-welcome-to-blfs)
			for rule in cmds:
				mainfile.write(rule)
	mainfile.close


def rmblock(path,block):
	lines = open(path).readlines()

	for k, v in OrderedDict(block).iteritems():
		
		try:                     
			blockstart = lines.index(k  + "\n")  
		except (ValueError,TypeError) as e:
			blockstart = ""
		try:
			blockend = lines.index(v + "\n",blockstart)
			
		except (ValueError,TypeError) as e:
			blockend = ""

		if blockend and blockstart:
			print "Removing Block:",k,v," between ",blockstart," and ",blockend
			del(lines[blockstart:blockend+1])  
        
	open(path, 'w+').writelines(lines)  



def rwreplace_delete_log():
	#print replace_delete_log
	replacefile= CWD + "/blfs_replace_delete.log"
	file = open(replacefile,'wb')	
	file.write(delete_log)
	file.write(replace_log)
	file.close
def create_wrapper():
	if not os.path.exists("/mnt/lfs/sbin"):
		os.makedirs("/mnt/lfs/sbin")
	file = open(wrapper,'wb')
	file.write(blfsbuild)
	file.close
	os.chmod(wrapper,0744)

base_init()
parseindex()
rwreplace_delete_log()
create_wrapper()




