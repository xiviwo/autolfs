#!/bin/env  python
# Version 1.05
# 
# 
# 
# 

import urllib2,os,binascii,re,sys,platform,glob,time
try:
	from collections import OrderedDict
except ImportError:
	from ordereddict import OrderedDict
try:
	from BeautifulSoup import BeautifulSoup
except ImportError:
	from bs4 import BeautifulSoup

total = len(sys.argv)
cmdargs = str(sys.argv)
def containsAny(str, set):
    """Check whether 'str' contains ANY of the chars in 'set'"""
    return 1 in [c in str for c in set]

def containsAll(str, set):
    """Check whether 'str' contains ALL of the chars in 'set'"""
    return 0 not in [c in str for c in set]


if total != 2 :
	print "Too much or less argument, it could be string like 'stable','development' or '7.4-rc1', any existing release\n"
	sys.exit(1)
else:
	release = sys.argv[1]


if not containsAny(release, ['stable','development','7.4-rc1']):
	print "Expected argument is 'stable','development'\n"
	sys.exit(1)

reload(sys) 
sys.setdefaultencoding('utf8')
homepage="http://www.linuxfromscratch.org/lfs/view/stable"
lfsloc="www.linuxfromscratch.org/lfs/view/" + release + "/index.html"
#blfsloc="www.linuxfromscratch.org/blfs/view/svn/index.html"

CWD=os.path.dirname(os.path.realpath(__file__))
output=CWD + "/cmds.sh"
LFS="/mnt/lfs"
SOURCES=LFS + '/sources'
lfspage=CWD + "/" + lfsloc

lfslocaldir=os.path.dirname(lfspage)


IP="192.168.122.13"
GATEWAY="192.168.122.2"
BROADCAST="192.168.122.255"
domain="ibm.com"
nameserver1 ="192.168.122.2"
nameserver2 ="192.168.122.1"
hostname= "alfs"
guestdev1="vda1"
guestdev2="vda2"
guestfs="ext3"
guestdev="vdb"
newuser = "mao"
passwd = "ping" 
hostdev1="vdb1"
hostdev2="vdb2"
arch=platform.machine()
if arch == 'i686':
	ABI=32
elif arch == 'x86_64':
	ABI=64
else:	
	print "Unknown platform error"
	raise 

wget_list=lfslocaldir + "/wget-list"
funcstrip= re.compile("\\b&nbsp;\\b|[ \~\:\+\.\-\?'\$\(\)\/\n\t\r]+",re.MULTILINE)
lastpkg = ""
makefile = "makefiles"
makefiledir = LFS + "/" + makefile
scriptfolder = makefiledir + "/scripts"
logfolder = makefiledir + "/logs"
firsttgt="all : download mk_env mk_tools mk_virt_file mk_chroot mk_config mk_boot mk_end umount_all"
comment="#This file is automatically generated, don't modify anyway\n"
comment += "#Generated time is : " +  time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()) + "\n"
replace_log=""
delete_log = ""
header='''\
BUILDDIR=  $(LFS)/$(MAKEDIR)
D	= -x
LFSHOME = /home/lfs
TOOLSDIR= $(LFS)/tools
SHELL 	= /bin/bash
SOURCES = $(LFS)/sources
LOGDIR	= $(BUILDDIR)/logs
SCRIPTDIR = $(BUILDDIR)/scripts
SCRIPTDIR2 = $(MAKEDIR)/scripts
REDIRECT= > $(LOGDIR)/$@.log 2>&1
USERENV = source $(LFSHOME)/.bashrc
BOLD    = "\e[0;1m"
RED     = "\e[1;31m"
GREEN   = "\e[0;32m"
ORANGE  = "\e[0;33m"
BLUE    = "\e[1;34m"
WHITE   = "\e[00m"
YELLOW  = "\e[1;33m"

OFF     = "\e[0m"
REVERSE = "\e[7m"

tab_    = '	'
nl_     = ''

export PATH := ${PATH}:/usr/sbin

CHROOT1= exec /usr/sbin/chroot $(LFS) /tools/bin/env -i HOME=/root TERM="$$TERM" PS1='\u:\w\$$ ' PATH=/bin:/usr/bin:/sbin:/usr/sbin:/tools/bin /tools/bin/bash --login +h -c

CHROOT2= exec /usr/sbin/chroot $(LFS) /usr/bin/env -i HOME=/root TERM="$$TERM" PS1='\u:\w\$$ ' PATH=/bin:/usr/bin:/sbin:/usr/sbin /bin/bash --login -c

define echo_message
  @echo -e $(BOLD)--------------------------------------------------------------------------------
  @echo -e $(BOLD)$(1) target $(BLUE)$@$(BOLD)$(WHITE)
endef
''' + firsttgt + '''\

download:
	@$(call echo_message, Building)
	@wget -nc --no-check-certificate -i $(WGETLIST) -P  $(SOURCES) $(REDIRECT)
	@touch $@

chown_dir: 
	$(call echo_message, Building)
	@chown  lfs.lfs $(BUILDDIR)
	@chown -R  lfs.lfs $(LOGDIR)
	@chown -R lfs.lfs $(SOURCES)
	
mk_env : download
	@$(call echo_message, Building)
	@make chapter4
	@touch $@

mk_tools: mk_env
	@$(call echo_message, Building)
	@exec env -i HOME=$(LFSHOME) TERM="$$TERM" PS1='\u:\w\$$ ' su lfs -c "source $(LFSHOME)/.bashrc && cd $(BUILDDIR) && make chapter5"
	@touch $@

mk_virt_file : mk_tools 
	@$(call echo_message, Building)
	@make virtfs
	@touch $@

mk_chroot : mk_virt_file
	@$(call echo_message, Building)
	@$(CHROOT1) "cd $(MAKEDIR) && make chapter6"
	@touch $@

mk_config : mk_chroot
	@$(call echo_message, Building)
	@$(CHROOT2) "cd $(MAKEDIR) && make chapter7"
	@touch $@

mk_boot : mk_config 
	@$(call echo_message, Building)
	@$(CHROOT2) "cd $(MAKEDIR) && make chapter8"
	@touch $@

mk_end : mk_boot
	@$(call echo_message, Building)
	@$(CHROOT2) "cd $(MAKEDIR) && make chapter9"
	@touch $@

umount_all :
ifndef LFS
	$(error LFS is not set)
else
	@-umount $(LFS)/sys
	@-umount $(LFS)/proc
	@-umount $(LFS)/dev/shm
	@-umount $(LFS)/dev/pts
	@-umount $(LFS)/dev
endif

clean : umount_all	
	@ rm -rf $(TOOLSDIR)/*
	@ rm -rf $(BUILDDIR)/$(ALLTGT)
	#@ rm -rf $(LOGDIR)/*

ifndef LFS
	$(error LFS is not set)
else
	@ -rm -rf $(LFS)/bin $(LFS)/boot $(LFS)/etc $(LFS)/home $(LFS)/lib $(LFS)/media $(LFS)/mnt $(LFS)/opt $(LFS)/root $(LFS)/sbin $(LFS)/srv $(LFS)/tmp $(LFS)/usr $(LFS)/var $(LFS)/sys $(LFS)/proc $(LFS)/run
	@ -rm -f $(LFS)/lib64
	@ -rmdir $(LFS)/tools 
	@ -rm -f /tools
endif

FORCE :

.SUFFIXES:

.PHONY: clean FORCE umount_all chown_dir


'''

header = "WGETLIST= " + wget_list + "\n" + header
header = "MAKEDIR= " + makefile + "\n" + header 
header = "LFS=" + LFS + "\n" + header





def base_init():

	if not os.path.exists(makefiledir):
		os.makedirs(makefiledir)	

	if not os.path.exists(scriptfolder):
		os.makedirs(scriptfolder)
	else :
		filelist = glob.glob(scriptfolder + "/*")
		for f in filelist:
			os.remove(f)
		#os.makedirs(scriptfolder)

	if not os.path.exists(logfolder):
		os.makedirs(logfolder)

	if not os.path.exists(lfslocaldir):
		os.system("wget --recursive  --no-clobber --html-extension  --convert-links  --restrict-file-names=windows  --domains www.linuxfromscratch.org   --no-parent " + lfsloc)



globalreplace = [
		('&gt;',						'>'),
		('&lt;',						'<'),
		('&amp;',						'&'),
		("IP=192.168.1.1",					"IP="+IP),
		("GATEWAY=192.168.1.2",					"GATEWAY=" + GATEWAY),
		("BROADCAST=192.168.1.255",				"BROADCAST=" + BROADCAST),
		('KEYMAP="de-latin1"',					'KEYMAP="us"'),
		('KEYMAP_CORRECTIONS="euro2"',				''),
		('LEGACY_CHARSET="iso-8859-15"',			''),
		('FONT="LatArCyrHeb-16 -m 8859-15"',			''),
		("zoneinfo/<xxx>",					"zoneinfo/Asia/Shanghai"),
		("PAGE=<paper_size>",					"PAGE=A4"),
		("chown -v",						"chown -Rv"),
		('DISTRIB_CODENAME="<your name here>"',			'DISTRIB_CODENAME="MAO"'),
		("passwd lfs",						"echo 'lfs:ping' | chpasswd"),
		("passwd root",					"echo 'root:ping' | chpasswd"),
		("make test",						""),
		("exec env -i HOME=$HOME TERM=$TERM PS1='\u:\w\$ ' /bin/bash",		"source /home/lfs/.bashrc"),
		("set root=(hd0,2)",					"set root=(hd0,1)"),
		("root=/dev/sda2 ro",					"root=/dev/" + guestdev1 + " ro"),
		("./configure --prefix=/usr --enable-cxx",		"ABI=" + str(ABI) +" \n\t./configure --prefix=/usr --enable-cxx"),
		("--with-libpam=no",					""),
		("./configure --sysconfdir=/etc",			"./configure --sysconfdir=/etc --with-libpam=no"),
		("make LANG=<host_LANG_value> LC_ALL= menuconfig",	'yes "" | make oldconfig'),
		("grub-install /dev/sda",				"grub-install /dev/" + guestdev ),
		#("build/udevadm hwdb --update", 			"sed -i 's/if ignore_if; then continue; fi/#&/' udev-lfs-197-2/init-net-rules.sh\nbuild/udevadm hwdb --update"),
		("bash udev-lfs-197-2/init-net-rules.sh",		'bash udev-lfs-197-2/init-net-rules.sh\nsed -i "s/\\"00:0c:29:[^\\".]*\\"/\\"00:0c:29:*:*:*\\"/" /etc/udev/rules.d/70-persistent-net.rules'),
		("useradd -m <newuser>",				'useradd -m ' + newuser),
		("<username>",						newuser),
		("<password>",						passwd),
		('export PATH="$PATH',					'export PATH=$PATH'),
		('groupadd lfs',					'groupadd lfs || true'),
		('useradd -s /bin/bash -g lfs -m -k /dev/null lfs',	'useradd -s /bin/bash -g lfs -m -k /dev/null lfs || true'),
		('cat > ~/.bash_profile << "EOF"',			'cat > /home/lfs/.bash_profile << "EOF"'),
		('cat > ~/.bashrc << "EOF"',				'cat > /home/lfs/.bashrc << "EOF"'),
		('source ~/.bash_profile',				'source /home/lfs/.bash_profile')
	 
	
		
]
globalregx = [
		(r"domain\s*<Your Domain Name>",				"domain " + domain),
		(r"nameserver\s*<IP address of your primary nameserver>",	"nameserver " + nameserver1),
		(r"nameserver\s*<IP address of your secondary nameserver>",	"nameserver " + nameserver2),
		(r"127\.0\.0\.1\s*<HOSTNAME\.example\.org>\s*<HOSTNAME>\s*localhost","127.0.0.1 localhost\n" + IP + "	alfs"),
		(r'echo\s*"HOSTNAME=<lfs>"\s*>\s*/etc/sysconfig/network',	'echo "HOSTNAME=' + hostname + '" > /etc/sysconfig/network'),
		(r"/dev/\s*<xxx>\s*/\s*<fff>",					'/dev/' + guestdev1 + '     /            ' + guestfs + '    '),
		(r"/dev/\s*<yyy>\s*swap\s*swap",					'/dev/' + guestdev2 + '    swap         swap'),
		(r"export\s*LANG=\s*<ll>_<CC>\.<charmap><@modifiers>",		"export LANG=en_US.utf8"),
		(r"mkdir\s*-v",						"mkdir -pv"),
		(r"mkdir\s*/",							"mkdir -pv /"),
		(r"mount\s*-v\s*-t\s*ext3\s*/dev/\s*<xxx>\s*\$LFS",		'mount -v -t ext3 /dev/' + hostdev1 + ' $LFS'),
		(r"/sbin/swapon\s*\-v\s*/dev/\s*<zzz>",			"/sbin/swapon -v /dev/" + hostdev2)

]

ignorelist = ['dummy',
	'libfoo',
	'make check',
	'localedef',
	'tzselect',
	'spawn ls',
	'ulimit',
	':options',
	'logout',
	'\nexit',
	'shutdown -r',
	'grub-img.iso',
	'hdparm -I /dev/sda | grep NCQ',
	'video4linux/',
	'make -k check',
	'make -k test',
	'make test',
	'udevadm test',
	'test_summary',
	"sed -i -e 's/\"write_cd_rules\"/\"write_cd_rules mode\"/' ",
	'83-cdrom-symlinks.rules',
	'cat /etc/udev/rules.d/70-persistent-net.rules',
	'locale -a',
	'locale name',
	'glibc-check-log',
	'su - lfs',
	'bash -e',
	'grep FATAL check.log',
	'<report-name.twr>',
	'readelf',
	'ABI=32 ./configure ...',
	'make NON_ROOT_USERNAME=nobody check-root',
	'su nobody -s /bin/bash ',
         '-c "PATH=$PATH make RUN_EXPENSIVE_TESTS=yes check"',
	'gmp-check-log',
	'mkdir -v $LFS/usr',
	'mount -v -t ext3 /dev/<yyy> $LFS/usr',
	'make RUN_EXPENSIVE_TESTS=yes check',
	'convmv',
	'</path/to/unzipped/files>',
	'lp -o number-up=2 <filename>',
	'gpg --verify ',
	'gpg gpg --keyserver pgp.mit.edu --recv-keys 0xF376813D',
	'cd /tmp &&',
	'exec /tools/bin/bash --login +h',
	'sed -i \'s/if ignore_if; then continue; fi/#&/\' udev-lfs-197-2/init-net-rules.sh',
	' /etc/udev/rules.d/70-persistent-net.rules',
	'chown -Rv nobody .',
	'exec /bin/bash --login +h',
	'/tools/bin/bash --login',
	'unset pathremove pathprepend pathappend',
	'mkdir -pv /etc/pam.d/',
	'patch -Np1 -i ../Python-2.7.3-bsddb_fix-1.patch &&',
	'tar xvf krb5-1.11.2.tar.gz',
	'cd krb5-1.11.2',
	"ABI=" + str(ABI),
	'install-catalog --add /etc/sgml/sgml-docbook-dtd-3.1.cat \\',
	'    /etc/sgml/sgml-docbook.cat',
	'sshfs THINGY:~ ~/MOUNTPATH',
	'fusermount -u ~/MOUNTPATH',
	'tripwire --init',
	"egrep '^flags.*(vmx|svm)' /proc/cpuinfo",
	'export LIBRARY_PATH=/opt/xorg/lib',
	"export MAKEFLAGS='-j 2'",
	"make -j2",
	'bash tests/run.sh'
	]

def massreplaceline(string):
	global replace_log
	for k, v in OrderedDict(globalreplace).iteritems():

		if k in string:
			#print "Replacing :",k," with :",v,"\n"
			
			replace_log += "\nOrigin    : " + string + "\n"
			replace_log += "Replacing : " + k + " with : " + v  + "\n"
			replace_log += "Rules     : " + k + "\n"
			replace_log += "-------------------------------------------------\n"
   			string = string.replace(k, v)
			return string 
	laststr = string
	for k, v in OrderedDict(globalregx).iteritems():
		
		#print laststr,"--------------------------"
		string = re.sub(k ,v, laststr)#,flags=re.DEBUG)
		#print string,"-====================="
		if string != laststr:
			#print string,"-====================="
			replace_log += "\nOrigin    : " + laststr + "\n"
			replace_log += "Replacing : " + laststr + " with : " + string  + "\n"
			replace_log += "Rules     : " + k + "\n"
			replace_log += "-------------------------------------------------\n"
		 

			return string
	return string



def replacem(str):
	if str !=None:
		return str.replace('&gt;','>').replace('&lt;','<').replace('&amp;','&')
	else:
		return 'REPLACEME'

def findchild(tag,tagname="kbd"):
	cmdline=""

	if tag.string!=None:
		tmpstr = replacem(tag.string)
		cmdline = cmdline + "\n" + tmpstr

	else:
		cmdline = cmdline + "\n"
		for code in tag.contents:
			#L2
			if code.string != None:
				cmdline = cmdline + replacem(code.string)
			else:
			
				for em in code.contents:
					#L3
					if em.string != None:
						cmdline = cmdline + "\t" +  replacem(em.string)
					
		cmdline = cmdline + "\n"						
	return cmdline

def grep(pattern,fileObj):
	
	for line in open(fileObj,'r'):
		
		if re.search(pattern,line):
			return line

def lineadd(lst,block,fullname):
	global delete_log
	if block:
		for i,line in enumerate(block.splitlines()):
			if line and line !="\n":
 
			 	if  containsAny(line,ignorelist):
					delete_log += "\n--------------------" + fullname + "-------------------------\n"
					delete_log += "Delete line : " + str(i) + " : " + line + " from :\n"
					delete_log += block + "\n"
					#delete_log += "\nDDDDDDDDDDDDDDDDDDDD" + fullname + "DDDDDDDDDDDDDDDDDDDDDDDDDD\n"
					
					pass
		   		else:
				
					lst.append(massreplaceline(line) + "\n")
					


def parsecmds(soupsub,link,fullname):


	namematch = re.search("^([a-zA-Z0-9]+(-[a-zA-Z]+)*)",fullname)
	shortname = namematch.group(1).lower()
	versionmatch = re.search("-([0-9.]+)",fullname)

	try:
		version = versionmatch.group(1)
	except AttributeError:
		version = ""
	
	if  not os.path.exists(wget_list):
		print "Can' not find " + wget_list
		sys.exit(1)
	if  "libstdc" in shortname:
		shortname = "gcc"
	if "udev" in shortname:
		shortname = "systemd"
	packlink = grep('/' + shortname + '[^/]*\.tar\.((bz2)|(xz)|(gz))$' ,wget_list)

	if packlink:
		packmat = re.search("/(" + shortname + "[^/]*\.tar\.((bz2)|(xz)|(gz))$)",packlink)
		packname = packmat.group(1)
	
	
	cmds=soupsub.findAll("kbd",{'class':'command'})
	cmdstr = []
	
	if  cmds:
		cmdstr.append("pkgname=" + shortname + "\n")
		cmdstr.append("version=" + version + "\n")
		cmdstr.append("export MAKEFLAGS='-j 4'\n")
		cmdstr.append("env\n")
		
		if packlink:

			cmdstr.append("cd ${SOURCES}\n")
			cmdstr.append("rm -rf ${pkgname}-${version} \n")
			cmdstr.append("rm -rf ${pkgname}-build" + "\n")
			cmdstr.append("mkdir -pv ${pkgname}-${version}  \n")
			cmdstr.append("tar xf " + packname + " -C ${pkgname}-${version} --strip-components 1\n")
			cmdstr.append("cd ${pkgname}-${version} \n")
		for cmd in cmds:
			
			lineadd(cmdstr,findchild(cmd),shortname + "-" + version) # cmd.text.encode('utf-8').strip() + "\n" #
		if packlink:	
			cmdstr.append("cd ${SOURCES}\n")
			cmdstr.append("rm -rf ${pkgname}-${version} \n")
			cmdstr.append("rm -rf ${pkgname}-build" + "\n")

		cmdstr.append("exit\n")

		
	return cmdstr



def parsepage(link,fullname):
		

		soupsub = BeautifulSoup(open(link).read())
		page=[]
		page = parsecmds(soupsub,link,fullname.lower())
		return page	

def genscript(links,ccounter,rules,subtarget):

	pcounter = 0
	global lastpkg 
	for link in links:	
		func =  funcstrip.sub("-",link.string).lower()
		
		namematch = re.search("^([a-zA-Z0-9]+(-[a-zA-Z]+)*)",func)
		shortname = namematch.group(1).lower()
		pkg = str(ccounter) + str(pcounter).zfill(2) + "-" + shortname
		print "Generating: ",func
		page= []
		subsect = []

		if link.has_attr("href") and not containsAny(func, ['chroot','package-management','cleaning-up','strip','rebooting','about-lfs','about-sbus']) :
			#Ignore those out of need
			sublink=os.path.dirname(lfspage) + "/"+link['href']

			page = parsepage(sublink,link.string)
		if page:
			packmkfile= scriptfolder + "/" + pkg + ".sh"
			file = open(packmkfile,'wb')	
			file.write("#/bin/bash\n")
			file.write("set +h\n")
			file.write("set -e\n\n\n")
			if ccounter > 5 and not containsAny(func, ["preparing-virtual"]) : #start from chapter 6
				file.write("LFS=\n" )
			else:
				file.write("LFS=" + LFS + "\n" )
			file.write("SOURCES=$LFS/sources\n" )
			for pag in page:
				file.write(pag)

			subsect += "\n" + pkg + " : " + lastpkg +"\n"
			subsect += "\t@$(call echo_message, Building)\n"

			subsect += "\t@$(SHELL) $(D) $(SCRIPTDIR)/$@.sh $(REDIRECT) \n"
	
			subsect += "\t@touch $@\n"
			lastpkg = pkg 

			
			if containsAny(func, ["changing-ownership"]):
				subtarget += "\nvirtfs : " + pkg + " 601-preparing-virtual-kernel-file-systems"
			elif not containsAny(func, ["preparing-virtual"]):
				subtarget += pkg + " "

			rules.extend(subsect)
			file.close
		pcounter +=1
	
	subtarget += "\n"
	return subtarget

def parseindex():


	soup = BeautifulSoup(open(lfspage).read())
	chapters =""
	chapter =""
	
	ccounter=0
	#pcounter=0
	rules = []
	titles=soup.findAll("h4")
	lfsversion=soup.findAll("h2",attrs={'class':"subtitle"})
	if lfsversion:
		for v in lfsversion:
			release = v.text
	#target = "all : mk_env mk_tools mk_chroot mk_config mk_boot mk_end "
	subtarget = ""
	
	once = 0 
	for title in titles:
		if ccounter > 3 :

			chapters = "chapter" + str(ccounter) 
			subtarget +=  chapters + " : " 
			if chapters in "chapter4" :
				subtarget += " chown_dir "
			uls=title.findNextSiblings()
			for ul in uls:
				links= ul.findAll("a")
				
				subtarget  = genscript(links,ccounter,rules,subtarget)
				#chapter5 : HOME=$(LFSHOME) TERM=xterm PS1='\u:\w\$$ '
				if "chapter5" in subtarget:
					subtarget += "chapter" + str(ccounter+1) + " : LFS= \n"
				if "chapter5" in subtarget and not once :
					subtarget += "chapter6 : SHELL=/tools/bin/bash \n"
					once = 1
				

		ccounter += 1

	if rules:
			mkfile= makefiledir + "/Makefile"
			mainfile = open(mkfile,'wb')	
			alltarget = re.sub(r'chapter[0-9]\s*:', '', subtarget)
			alltarget = alltarget.replace("\n","") + firsttgt.replace("all :","")
			mainfile.write(comment + "#Current BLFS release is : " + release.replace("\n","") + "\n" )
			mainfile.write(header+ "ALLTGT= " + alltarget + "\n" )
			mainfile.write(subtarget)
			for rule in rules:
				mainfile.write(rule)
	mainfile.close


def rmblock(path,block):
	lines = open(path).readlines()
	#for a in lines:
	#	print a
	for k, v in OrderedDict(block).iteritems():
		
		try:                     
			blockstart = lines.index(k  + "\n")  
		except (ValueError,TypeError) as e:
			blockstart = ""
		try:
			blockend = lines.index(v + "\n",blockstart)
			
		except (ValueError,TypeError) as e:
			blockend = ""
		#print blockstart,blockend
		if blockend and blockstart:
			print "Removing Block:",k,v," between ",blockstart," and ",blockend
			del(lines[blockstart:blockend+1])  
		#return lines  
	#print "-------------------------------------"
	#for a in lines:
	#	print a           
	open(path, 'w+').writelines(lines)  


def massreplaceall(fileobj):
	
	#lines = open(fileobj)
	#print type(lines)
	retlines= []

	for i,line in enumerate(open(fileobj)):
		#print line
		if  containsAny(line,ignorelist):
			print "Delete line:",i,":",line
			pass
   		else:
			#print line
			line = massreplaceline(line)
			#print line
			retlines.append(line)
			 # sys.stdout is redirected to the file
	open(fileobj, 'w+').writelines(retlines)  
			#sys.stdout.write(line)

def rwreplace_delete_log():
	#print replace_delete_log
	replacefile= CWD + "/replace_delete.log"
	file = open(replacefile,'wb')	
	file.write(delete_log)
	file.write(replace_log)
	file.close


base_init()
parseindex()
rwreplace_delete_log()
#parseindex(blfspage,file)





